<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Usando tipos de dados avançados</title><meta name="Language" content="pt-br" /><meta name="System.Keywords" content="tipos de dados avançados" /><meta name="Microsoft.Help.Id" content="b39461d3-48d6-4048-8300-1a886c00756d" /><meta name="Description" content="O Microsoft JDBC Driver para SQL Server usa os tipos de dados avançados JDBC para converter os tipos de dados do SQL Server em um formato que possa ser compreendido pela linguagem de programação Java." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Usando tipos de dados avançados</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>O Microsoft JDBC Driver para SQL Server usa os tipos de dados avançados JDBC para converter os tipos de dados do SQL Server em um formato que possa ser compreendido pela linguagem de programação Java. </p></div><h1 class="heading">Comentários</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>A tabela a seguir lista os mapeamentos padrão entre o SQL Server avançado, o JDBC e os tipos de dados da linguagem de programação Java.</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>Tipos de SQL Server</p></th><th><p>Tipos JDBC (java.sql.Types)</p></th><th><p>Tipos da linguagem Java</p></th></tr><tr><td><p>varbinary(max)</p><p>imagem</p></td><td><p>LONGVARBINARY</p></td><td><p>byte[] (default), Blob, InputStream, String</p></td></tr><tr><td><p>text</p><p>varchar(max)</p></td><td><p>LONGVARCHAR</p></td><td><p>String (default), Clob, InputStream</p></td></tr><tr><td><p>ntext</p><p>nvarchar(max)</p></td><td><p>LONGVARCHAR</p><p>LONGNVARCHAR (Java SE 6.0)</p></td><td><p>String (default), Clob, NClob (Java SE 6.0)</p></td></tr><tr><td><p>xml</p></td><td><p>LONGVARCHAR</p><p>SQLXML (Java SE 6.0)</p></td><td><p>String (default), InputStream, Clob, byte[],Blob, SQLXML (Java SE 6.0)</p></td></tr><tr><td><p>udt</p></td><td><p>VARBINARY</p></td><td><p>String (default), byte[], InputStream</p></td></tr></table></div><p>As seguintes seções fornecem exemplos de como é possível usar o driver JDBC e os tipos de dados avançados.</p></div><h1 class="heading">Tipos de dados BLOB e CLOB e NCLOB</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>O JDBC Driver implementa todos os métodos das interfaces java.sql.Blob, java.sql.Clob e java.sql.NClob. </p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Os valores CLOB podem ser usados com tipos de dados de valor grande do SQL Server 2005 (ou posterior). Especificamente, tipos CLOB podem ser usados com os tipos de dados <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span> e <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>, tipos BLOB podem ser usados com tipos de dados <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> e <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, e tipos NCLOB podem ser usados com <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> e <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div></div><h1 class="heading">Tipos de dados de valor grande</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Em versões anteriores do SQL Server, trabalhar com tipos de dados de valor grande exigia procedimentos especiais. Os tipos de dados de valor grande são aqueles que excedem o tamanho de linha máximo de 8 KB. O SQL Server introduz um especificador max para tipos de dados <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span>, <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> e <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span> a fim de permitir o armazenamento de valores de até 2^31 bytes. Colunas de tabela e variáveis Transact-SQL podem especificar tipos de dados <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span>, <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span> ou <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>.</p><p>Os cenários primários para trabalhar com tipos de valor grande envolvem recuperá-los de um banco de dados ou adicioná-los a um banco de dados. As seções a seguir descrevem abordagens diferentes para realizar estas tarefas.</p><h1 class="heading">Recuperando tipos de valor grande de um banco de dados</h1><div class="subsection"><p>Quando você recuperar um tipo de dados de valor grande não binário — como o tipo de dados <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span> — de um banco de dados, uma abordagem é ler esses dados como um fluxo de caracteres. No exemplo seguinte, o método <a href="599cf463-e19f-4baa-bacb-513cad7c6cd8.htm">executeQuery</a> da classe <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> é usado para recuperar dados do banco de dados e retorná-los como conjunto de resultados. Em seguida, o método <a href="c70e210f-0288-47cc-9268-a29c45979729.htm">getCharacterStream</a> da classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> é usado para ler os dados de valor grande do conjunto de resultados.</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT TOP 1 * FROM Test1");
rs.next();
Reader reader = rs.getCharacterStream(2);</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Esta mesma abordagem também pode ser usada para os tipos de dados <span sdata="langKeyword" value="text"><span class="keyword">text</span></span>, <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> e <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div><p>Quando você recuperar um tipo de dados de valor grande e binário — como o tipo de dados <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> — de um banco de dados, existem diversas abordagens que você pode adotar. A abordagem mais eficiente é ler os dados como um fluxo binário, da seguinte maneira:</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
rs.next();
InputStream is = rs.getBinaryStream(2);</pre></span></div><p>Você também pode usar o método <a href="d16a0aea-6144-4fcb-bcbc-5d7daa36d327.htm">getBytes</a> para ler os dados como uma matriz de bytes, da seguinte maneira:</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
rs.next();
byte [] b = rs.getBytes(2);</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Você também pode ler os dados como um BLOB. Porém, isto é menos eficiente que os dois métodos mostrados previamente.</p></div></div><h1 class="heading">Adicionando tipos de valor grande a um banco de dados</h1><div class="subsection"><p>Carregar dados grandes com o driver JDBC funciona bem para os casos dimensionados por memória; nos casos maiores que a memória, streaming é a opção primária. Porém, o modo mais eficiente de carregar dados grandes é pelas interfaces de fluxo.</p><p>Usar uma cadeia de caracteres ou bytes também é uma opção, da seguinte maneira:</p><div class="sampleCode"><span codeLanguage="other"><pre>PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 (c1_id, c2_vcmax) VALUES (?, ?)");
pstmt.setInt(1, 1);
pstmt.setString(2, htmlStr);
pstmt.executeUpdate();</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Esta abordagem também pode ser usada para obter valores que são armazenados nas colunas <span sdata="langKeyword" value="text"><span class="keyword">text</span></span>, <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> e <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div><p>Se você tiver uma biblioteca de imagem no servidor e precisar carregar arquivos de imagem binários inteiros para uma coluna <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>, o método mais eficiente com o driver JDBC será usar fluxos diretamente, da seguinte maneira:</p><div class="sampleCode"><span codeLanguage="other"><pre>PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 (Col1, Col2) VALUES(?,?)");
File inputFile = new File("CLOBFile20mb.jpg");
FileInputStream inStream = new FileInputStream(inputFile);
int id = 1;
pstmt.setInt(1,id);
pstmt.setBinaryStream(2, inStream);
pstmt.executeUpdate();
inStream.close();</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Usar o método CLOB ou BLOB não é uma maneira eficiente de carregar dados grandes.</p></div></div><h1 class="heading">Modificando tipos de valor grande em um banco de dados</h1><div class="subsection"><p>Na maioria dos casos, o método indicado para atualizar ou modificar valores grandes no banco de dados é passar parâmetros pelas classes <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> e <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a> usando comandos Transact-SQL como UPDATE, WRITE e SUBSTRING.</p><p>Se você tiver que substituir a instância de uma palavra em um arquivo de texto grande, como um arquivo HTML, poderá usar um objeto <b>Clob</b>, da seguinte maneira:</p><div class="sampleCode"><span codeLanguage="other"><pre>String SQL = "SELECT * FROM test1;";
Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
ResultSet rs = stmt.executeQuery(SQL);
rs.next();

Clob clob = rs.getClob(2);
long pos = clob.position("dog", 1);
clob.setString(pos, "cat");
rs.updateClob(2, clob);
rs.updateRow();</pre></span></div><p>Adicionalmente, você pode fazer todo o trabalho no servidor e só passar parâmetros para uma instrução UPDATE preparada.</p><p>Para obter mais informações sobre tipos de valor grande, consulte "Usando tipos de valor grande" nos Manuais Online do SQL Server.</p></div></div><h1 class="heading">Tipo de dados XML</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>O SQL Server fornece um tipo de dados <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> que permite armazenar fragmentos e documentos XML em um banco de dados do SQL Server. O tipo de dados <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> é interno no SQL Server e, em alguns aspectos, é semelhante a outros tipos internos, como <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> e <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span>. Assim como em outros tipos internos, você pode usar o tipo de dados <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> como um tipo de coluna quando cria uma tabela; como um tipo de variável, de parâmetro ou de retorno de função; ou em funções CAST e CONVERT do Transact-SQL .</p><p>No driver JDBC, o tipo de dados <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> pode ser mapeado como um objeto de Cadeia de Caracteres, matriz de bytes, fluxo, CLOB, BLOB ou SQLXML. Cadeia de caracteres é o padrão. A partir do JDBC Driver versão 2.0, o driver JDBC dá suporte à API do JDBC 4.0, que apresenta a interface SQLXML. A interface SQLXML define métodos para interagir com dados XML e manipulá-los. O tipo de dados <span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span> mapeia para o tipo de dados <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> do SQL Server. Para obter mais informações sobre como ler e escrever dados XML de e para o banco de dados relacional com o tipo de dados <span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span> Java, consulte <span sdata="link"><a href="32b7217e-1f0c-473d-9a45-176daa81584e.htm">Dando suporte a dados XML</a></span>.</p><p>A implementação do tipo de dados <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> no driver JDBC fornece suporte para o seguinte:</p><ul><li><p>Acesso ao XML como uma cadeia de caracteres Java UTF-16 padrão para a maioria dos cenários comuns de programação</p></li><li><p>Entrada de UTF-8 e outros XML codificados de 8 bits</p></li><li><p>Acesso ao XML como uma matriz de byte com um BOM principal quando for codificado em UTF-16 para intercâmbio com outros processadores de XML e arquivos em disco</p></li></ul><p>O SQL Server exige um BOM principal para XML codificado como UTF-16. O aplicativo deve fornecer isto quando os valores de parâmetro de XML são fornecidos como matrizes de byte. O SQL Server sempre produz valores XML como cadeias de caracteres de UTF-16 sem BOM ou declaração de codificação incorporada. Quando os valores XML são recuperados como byte[], BinaryStream ou Blob, um BOM UTF-16 é pré-demarcado no valor.</p><p>Para obter mais informações sobre os tipos de dados <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span>, veja "Tipo de dados xml" nos Manuais online do SQL Server.</p></div><h1 class="heading">Tipo de dados definido pelo usuário</h1><div id="sectionSection4" class="section" name="collapseableSection" style=""><p>A introdução de tipos definidos pelo usuário (UDTs) no SQL Server 2005 estende o sistema de tipos de SQL, permitindo armazenar objetos e estruturas de dados personalizadas em um banco de dados do SQL Server. Os UDTs podem conter vários tipos de dados e ter comportamentos, o que os diferencia dos tipos de dados de alias tradicionais, que consistem em um único tipo de dado do sistema no SQL Server. As UDTs são definidas por usarem qualquer uma das linguagens para as quais o CLR do Microsoft .NET Framework oferece suporte e que produzem código verificável. Isto inclui Microsoft Visual C# e Visual Basic .NET. Os dados são expostos como campos e propriedades de uma classe ou estrutura baseada no .NET Framework, e os comportamentos são definidos pelos métodos da classe ou estrutura. </p><p>No SQL Server, um UDT pode ser usado como definição da coluna de uma tabela, como uma variável em um lote do Transact-SQL ou como um argumento de uma função Transact-SQL ou procedimento armazenado.</p><p>Para obter mais informações sobre tipos de dados definidos pelo usuário, consulte "Usando e modificando instâncias de tipos definidos pelo usuário" nos Manuais online do SQL Server.</p></div><span id="seeAlsoSpan"><h1 class="heading">Consulte também</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">Entendendo os tipos de dados do JDBC Driver</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Envie <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dObrigado%20por%20seus%20comentários.%20As%20equipes%20de%20desenvolvimento%20usam%20seus%20comentários%20para%20melhorar%20a%20documentação.%20Enquanto%20estivermos%20examinando%20seus%20comentários%20,%20poderemos%20enviar%20um%20email%20solicitando%20mais%20esclarecimentos%20ou%20comentários%20sobre%20a%20solução%20encontrada%20.%20Não%20usaremos%20seu%20endereço%20de%20email%20para%20nenhum%20outro%20propósito%20e%20o%20excluiremos%20após%20concluirmos%20a%20análise.%0\APara%20obter%20informações%20sobre%20a%20política%20de%20privacidade%20da%20Microsoft,%20consulte%20http://privacy.microsoft.com/pt-br/default.aspx.%0\A%0\d','Comentários%20do%20cliente.');">comentários</a> sobre este tópico à Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Todos os direitos reservados.</a></p></span></div></div></body></html>