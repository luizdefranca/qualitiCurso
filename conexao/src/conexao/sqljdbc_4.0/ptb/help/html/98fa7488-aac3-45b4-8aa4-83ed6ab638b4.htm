<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Entendendo conversões de tipo de dados</title><meta name="Language" content="pt-br" /><meta name="System.Keywords" content="conversões de tipo de dados" /><meta name="Microsoft.Help.Id" content="98fa7488-aac3-45b4-8aa4-83ed6ab638b4" /><meta name="Description" content="Para facilitar a conversão de tipos de dados da linguagem de programação Java em tipos de dados do SQL Server, o Microsoft JDBC Driver para SQL Server fornece conversões de tipo de dados, conforme exigido pela especificação de JDBC." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Entendendo conversões de tipo de dados</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Para facilitar a conversão de tipos de dados da linguagem de programação Java em tipos de dados do SQL Server, o Microsoft JDBC Driver para SQL Server fornece conversões de tipo de dados, conforme exigido pela especificação de JDBC. Para garantir flexibilidade, todos os tipos são conversíveis para e de tipos de dados <span sdata="langKeyword" value="Object"><span class="keyword">Object</span></span>, <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> e <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. </p></div><h1 class="heading">Conversões de método getter</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>Com base nos tipos de dados do SQL Server, o gráfico seguinte contém o mapa de conversão do driver JDBC para os métodos <b>get&lt;Type&gt;()</b> da classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> e as conversões com suporte para os métodos <b>get&lt;Type&gt;</b> da classe <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>.</p><img alt="JDBCGetterConversions" src="../art/JDBCGetterConversions.gif" /><p>Há três categorias de conversões que têm suporte pelos métodos getter do driver JDBC:</p><ul><li><p><span class="label">Sem perda (x)</span>: as conversões para casos em que o tipo getter é o mesmo ou menor que o tipo de servidor subjacente. Por exemplo, ao chamar <b>getBigDecimal</b> em uma coluna decimal do servidor subjacente, nenhuma conversão é necessária.</p></li><li><p><span class="label">Convertido (y)</span>: as conversões de tipos de servidores numéricos para tipos da linguagem Java em que a conversão é normal e segue as regras de conversão da linguagem Java. Para estas conversões, a precisão é sempre truncada — nunca arredondada — e o estouro é tratado como módulo do tipo de destino, que é menor. Por exemplo, chamar <b>getInt</b> em uma coluna <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> subjacente que contém "1.9999" retornará "1", ou se o valor <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> subjacente for "3000000000", o valor <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> estourará para "-1294967296."</p></li><li><p><span class="label">Dependente de dados (z)</span>: as conversões de tipos de caracteres subjacentes para tipos numéricos exigem que os tipos de caracteres contenham valores que podem ser convertidos naquele tipo. Nenhuma outra conversão é realizada. Se o valor for muito grande para o tipo getter, o valor não será válido. Por exemplo, se <b>getInt</b> for chamado em uma coluna de varchar(50) que contém "53", o valor será retornado como um <span sdata="langKeyword" value="int"><span class="keyword">int</span></span>; mas se o valor subjacente for "xyz" ou "3000000000", um erro será lançado.</p></li></ul><p>Se <b>getString</b> for chamado em um tipo de dados de coluna <span sdata="langKeyword" value="binary"><span class="keyword">binary</span></span>, <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span>, <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> ou <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, o valor será retornado como um valor hexadecimal da cadeia de caracteres.</p></div><h1 class="heading">Conversões de método updater</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Para os dados de tipo Java passados para os métodos <b>update&lt;Type&gt;()</b> da classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>, as conversões a seguir se aplicam.</p><img alt="JDBCUpdaterConversions" src="../art/JDBC_JDBCUpdatterConversions.gif" /><p>Há três categorias de conversões que têm suporte pelos métodos updater do driver JDBC:</p><ul><li><p><span class="label">Sem perda (x)</span>: as conversões para casos em que o tipo updater é o mesmo ou menor que o tipo de servidor subjacente. Por exemplo, ao chamar <b>updateBigDecimal</b> em uma coluna decimal do servidor subjacente, nenhuma conversão é necessária.</p></li><li><p><span class="label">Convertido (y)</span>: as conversões de tipos de servidores numéricos para tipos da linguagem Java em que a conversão é normal e segue as regras de conversão da linguagem Java. Para estas conversões, a precisão é sempre truncada (nunca arredondada) e o estouro é tratado como módulo do tipo de destino (menor). Por exemplo, chamar <b>updateDecimal</b> em uma coluna <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> subjacente que contém "1.9999" retornará "1", ou se o valor <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> subjacente for "3000000000", o valor <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> estourará para "-1294967296."</p></li><li><p><span class="label">Dependente de dados (z)</span>: as conversões de tipos de dados de origem subjacentes para tipos de dados de destino exigem que os valores contidos sejam convertidos em tipos de destino. Nenhuma outra conversão é realizada. Se o valor for muito grande para o tipo getter, o valor não será válido. Por exemplo, se <b>updateString</b> for chamado em uma coluna int que contenha "53", a atualização será bem-sucedida; mas se o valor subjacente de String for "foo" ou "3000000000", um erro será lançado.</p></li></ul><p>Quando <b>updateString</b> é chamado em um tipo de dados de coluna <span sdata="langKeyword" value="binary"><span class="keyword">binary</span></span>, <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span>, <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> ou <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, ele trata o valor de String como um valor hexadecimal da cadeia de caracteres.</p><p>Quando o tipo de dados de coluna do SQL Server for <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, o valor de dados deverá ser um <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> válido. Ao chamar os métodos <b>updateBytes</b>, <b>updateBinaryStream</b> ou <b>updateBlob</b>, o valor de dados deverá ser a representação de cadeia de caracteres hexadecimal dos caracteres XML. Por exemplo: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Observe que uma marca de ordem de byte (BOM) é exigida se os caracteres XML estiverem em codificações de caracteres específicas.</p></div><h1 class="heading">Conversões de método setter</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Para os dados de tipo Java passados para os métodos <b>set&lt;Type&gt;()</b> da classe <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> e da classe <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>, as conversões a seguir se aplicam.</p><img alt="JDBCSetterConversions" src="../art/JDBC_JDBCSetterConversions_v2.gif" /><p>O servidor experimenta qualquer conversão e retorna erros quando há falha.</p><p>No caso do tipo de dados <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>, se o valor exceder o comprimento de <span sdata="langKeyword" value="VARCHAR"><span class="keyword">VARCHAR</span></span>, ele mapeará para <span sdata="langKeyword" value="LONGVARCHAR"><span class="keyword">LONGVARCHAR</span></span>. Da mesma forma, <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span> mapeará para <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span> se o valor exceder o comprimento do <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span> que tem suporte. O mesmo é válido para <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. Valores mais longos que <span sdata="langKeyword" value="VARBINARY"><span class="keyword">VARBINARY</span></span> tornam-se <span sdata="langKeyword" value="LONGVARBINARY"><span class="keyword">LONGVARBINARY</span></span>.</p><p>Há duas categorias de conversões que têm suporte pelos métodos setter do driver JDBC:</p><ul><li><p><span class="label">Sem perda (x)</span>: as conversões para casos numéricos em que o tipo setter é o mesmo ou menor que o tipo de servidor subjacente. Por exemplo, ao chamar <b>setBigDecimal</b> em uma coluna <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> do servidor subjacente, nenhuma conversão é necessária. Para casos de numérico para caractere, o tipo de dados Java <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> é convertido para uma <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>. Por exemplo, chamar <b>setDouble</b> com um valor de "53" em uma coluna de varchar (50) gera um valor de caractere "53" na coluna de destino.</p></li><li><p><span class="label">Convertido (y)</span>: conversões de um tipo Java <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> para um tipo <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> de servidor subjacente que é menor. Esta conversão é normal e segue as convenções de conversão do SQL Server. A precisão sempre é truncada (nunca arredondada) e o estouro lança um erro de conversão sem suporte. Por exemplo, usar <b>updateDecimal</b> com um valor de "1.9999" em uma coluna de inteiro subjacente resulta em um "1" na coluna de destino; mas se for passado "3000000000", o driver lançará um erro.</p></li><li><p><span class="label">Dependente de dados (z)</span>: conversões de um tipo Java <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> para o tipo de dados subjacente do SQL Server dependem das seguintes condições: o driver envia o valor de <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> para o SQL Server e o SQL Server realizarem as conversões, se necessário. Se <b>sendStringParametersAsUnicode</b> for definido como true e o tipo de dados adjacente do SQL Server for <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, o SQL Server não permitirá a conversão de <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> em <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> e gerará um <b>SQLServerException</b>. Se sendStringParametersAsUnicode for definido como false e o tipo de dados subjacente do SQL Server for <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, o SQL Server permitirá a conversão de <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span> em <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> e não gerará uma exceção.</p></li></ul><p>O SQL Server realiza as conversões e passa os erros de volta para o driver JDBC quando há problemas.</p><p>Quando o tipo de dados de coluna do SQL Server for <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, o valor de dados deverá ser um <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> válido. Ao chamar os métodos <b>updateBytes</b>, <b>updateBinaryStream</b> ou <b>updateBlob</b>, o valor de dados deverá ser a representação de cadeia de caracteres hexadecimal dos caracteres XML. Por exemplo: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Observe que uma marca de ordem de byte (BOM) é exigida se os caracteres XML estiverem em codificações de caracteres específicas.</p></div><h1 class="heading">Conversões em setObject</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>Para os dados de tipo Java passados para os métodos <b>setObject(&lt;Type&gt;)</b> da classe <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a>, as conversões a seguir se aplicam. </p><img alt="JDBCSetObjectConversions" src="../art/JDBC_JDBCSetObjectConversions.gif" /><p>O método <b>setObject</b> sem tipo designado especificado usa o mapeamento padrão. No caso do tipo de dados <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>, se o valor exceder o comprimento de <span sdata="langKeyword" value="VARCHAR"><span class="keyword">VARCHAR</span></span>, ele mapeará para <span sdata="langKeyword" value="LONGVARCHAR"><span class="keyword">LONGVARCHAR</span></span>. Da mesma forma, <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span> mapeará para <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span> se o valor exceder o comprimento do <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span> que tem suporte. O mesmo é válido para <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. Valores mais longos que <span sdata="langKeyword" value="VARBINARY"><span class="keyword">VARBINARY</span></span> tornam-se <span sdata="langKeyword" value="LONGVARBINARY"><span class="keyword">LONGVARBINARY</span></span>.</p><p>Há três categorias de conversões que têm suporte pelos métodos setObject do driver JDBC:</p><ul><li><p><span class="label">Sem perda (x)</span>: as conversões para casos numéricos em que o tipo setter é o mesmo ou menor que o tipo de servidor subjacente. Por exemplo, ao chamar <b>setBigDecimal</b> em uma coluna <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> do servidor subjacente, nenhuma conversão é necessária. Para casos de numérico para caractere, o tipo de dados Java <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> é convertido para uma <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>. Por exemplo, chamar <b>setDouble</b> com um valor de "53" em uma coluna de varchar (50) gerará um valor de caractere "53" na coluna de destino.</p></li><li><p><span class="label">Convertido (y)</span>: conversões de um tipo Java <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> para um tipo <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> de servidor subjacente que é menor. Esta conversão é normal e segue as convenções de conversão do SQL Server. A precisão sempre é truncada — nunca arredondada — e o estouro lança um erro de conversão sem suporte. Por exemplo, usar <b>updateDecimal</b> com um valor de "1.9999" em uma coluna de inteiro subjacente resulta em um "1" na coluna de destino; mas se for passado "3000000000", o driver lançará um erro.</p></li><li><p><span class="label">Dependente de dados (z)</span>: conversões de um tipo Java <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> para o tipo de dados subjacente do SQL Server dependem das seguintes condições: o driver envia o valor de <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> para o SQL Server e o SQL Server realizarem as conversões, se necessário. Se a propriedade de conexão <b>sendStringParametersAsUnicode</b> estiver definida como true e o tipo de dados subjacente do SQL Server for <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, o SQL Server não permitirá a conversão de <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> em <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> e gerará um SQLServerException. Se <b>sendStringParametersAsUnicode</b> estiver definida como false e o tipo de dados subjacente do SQL Server for <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, o SQL Server permitirá a conversão de <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span> em <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> e não gerará uma exceção.</p></li></ul><p>O SQL Server realiza o conjunto de conversões em massa e passa os erros de volta para o driver JDBC quando há problemas. As conversões do lado do cliente são a exceção e são realizadas somente no caso de valores <span sdata="langKeyword" value="date"><span class="keyword">date</span></span>, <span sdata="langKeyword" value="time"><span class="keyword">time</span></span>, <span sdata="langKeyword" value="timestamp"><span class="keyword">timestamp</span></span>, <span sdata="langKeyword" value="Boolean"><span class="keyword">Boolean</span></span> e <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>.</p><p>Quando o tipo de dados de coluna do SQL Server for <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, o valor de dados deverá ser um <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> válido. Ao chamar os métodos setObject (byte [], SQLXML), setObject (inputStream, SQLXML) ou setObject (Blob, SQLXML), o valor de dados deverá ser a representação hexadecimal da cadeia dos caracteres XML. Por exemplo: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Observe que uma marca de ordem de byte (BOM) é exigida se os caracteres XML estiverem em codificações de caracteres específicas.</p></div><span id="seeAlsoSpan"><h1 class="heading">Consulte também</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">Entendendo os tipos de dados do JDBC Driver</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Envie <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dObrigado%20por%20seus%20comentários.%20As%20equipes%20de%20desenvolvimento%20usam%20seus%20comentários%20para%20melhorar%20a%20documentação.%20Enquanto%20estivermos%20examinando%20seus%20comentários%20,%20poderemos%20enviar%20um%20email%20solicitando%20mais%20esclarecimentos%20ou%20comentários%20sobre%20a%20solução%20encontrada%20.%20Não%20usaremos%20seu%20endereço%20de%20email%20para%20nenhum%20outro%20propósito%20e%20o%20excluiremos%20após%20concluirmos%20a%20análise.%0\APara%20obter%20informações%20sobre%20a%20política%20de%20privacidade%20da%20Microsoft,%20consulte%20http://privacy.microsoft.com/pt-br/default.aspx.%0\A%0\d','Comentários%20do%20cliente.');">comentários</a> sobre este tópico à Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Todos os direitos reservados.</a></p></span></div></div></body></html>